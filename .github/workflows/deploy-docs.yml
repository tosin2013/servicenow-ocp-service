name: Deploy Documentation to GitHub Pages

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/**'
      - '.github/workflows/deploy-docs.yml'
  workflow_dispatch:
    inputs:
      skip_link_validation:
        description: 'Skip link validation (not recommended)'
        required: false
        default: false
        type: boolean

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Validate links before deployment
  validate-links:
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_link_validation != 'true'
    outputs:
      validation-passed: ${{ steps.validation.outputs.passed }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Set up Node.js for link checking
      uses: actions/setup-node@v4
      with:
        node-version: '18'
    
    - name: Install link checking tools
      run: |
        npm install -g markdown-link-check
        sudo apt-get update && sudo apt-get install -y curl jq
    
    - name: Create reports directory
      run: mkdir -p docs/reports
    
    - name: Run link validation
      id: validation
      run: |
        echo "üîç Validating documentation links before deployment..."
        
        # Run our custom validation script
        if ./docs/scripts/validate-links.sh --external-only --timeout 10 --report-format json --output docs/reports/pre-deploy-validation.json; then
          echo "‚úÖ Link validation passed"
          echo "passed=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Link validation failed"
          echo "passed=false" >> $GITHUB_OUTPUT
          exit 1
        fi
    
    - name: Upload validation report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: pre-deploy-validation-report
        path: docs/reports/
        retention-days: 7

  # Build and deploy documentation
  deploy:
    runs-on: ubuntu-latest
    needs: validate-links
    if: always() && (needs.validate-links.result == 'success' || github.event.inputs.skip_link_validation == 'true')
    
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for git info in docs
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'
    
    - name: Install MkDocs and dependencies
      run: |
        cd docs
        pip install -r requirements.txt
    
    - name: Configure git for MkDocs
      run: |
        git config --global user.name "GitHub Actions"
        git config --global user.email "actions@github.com"
    
    - name: Build documentation
      run: |
        cd docs
        echo "üèóÔ∏è Building MkDocs documentation..."
        mkdocs build --verbose
        
        # Verify build output - comprehensive recursive test
        echo "üîç Verifying build output..."

        # Basic structure check
        if [ ! -d "site" ] || [ ! -f "site/index.html" ]; then
          echo "‚ùå MkDocs build failed - no site directory or index.html"
          exit 1
        fi

        # Dynamic discovery of expected pages from source content
        echo "üîç Discovering expected pages from source content..."

        # Find all markdown files in content directory and convert to expected HTML paths
        EXPECTED_PAGES=()
        MISSING_PAGES=()

        # Add index.html (always required)
        EXPECTED_PAGES+=("site/index.html")

        # Scan content directory for markdown files
        if [ -d "content" ]; then
          while IFS= read -r -d '' file; do
            # Convert content/path/file.md to site/path/file/index.html
            relative_path="${file#content/}"
            if [[ "$relative_path" == "index.md" ]]; then
              # Skip - already handled above
              continue
            elif [[ "$relative_path" == */index.md ]]; then
              # Skip subdirectory index.md files - MkDocs handles these differently
              continue
            elif [[ "$relative_path" == */README.md ]]; then
              # Skip README.md files - MkDocs may not build these as separate pages
              continue
            elif [[ "$relative_path" == *.md ]]; then
              # Remove .md extension and add /index.html
              html_path="site/${relative_path%.md}/index.html"
              EXPECTED_PAGES+=("$html_path")
            fi
          done < <(find content -name "*.md" -type f -print0 2>/dev/null)
        fi

        echo "üìã Found ${#EXPECTED_PAGES[@]} expected pages from source content"
        echo "üîç Checking if all expected pages were built..."

        for page in "${EXPECTED_PAGES[@]}"; do
          if [ ! -f "$page" ]; then
            echo "‚ùå Missing: $page"
            MISSING_PAGES+=("$page")
          else
            echo "‚úÖ Found: $page"
          fi
        done

        # Report missing pages
        if [ ${#MISSING_PAGES[@]} -gt 0 ]; then
          echo ""
          echo "‚ùå BUILD VERIFICATION FAILED"
          echo "Missing ${#MISSING_PAGES[@]} expected pages:"
          printf '%s\n' "${MISSING_PAGES[@]}"
          echo ""
          echo "üîç Debugging information:"
          echo "Working directory: $(pwd)"
          echo ""
          echo "üìÅ Source content structure:"
          find content -name "*.md" -type f 2>/dev/null | head -20 || echo "No content directory found"
          echo ""
          echo "üìÅ Built site directory contents:"
          ls -la site/ 2>/dev/null || echo "No site directory found"
          echo ""
          echo "üìÅ Built site subdirectories:"
          find site -type d 2>/dev/null | head -20 || echo "Cannot list site subdirectories"
          echo ""
          echo "üìÑ Built HTML files:"
          find site -name "*.html" -type f 2>/dev/null | head -20 || echo "No HTML files found"
          exit 1
        fi
        
        echo "‚úÖ Documentation built successfully"
        echo "üìä Site statistics:"
        find site -name "*.html" | wc -l | xargs echo "HTML files:"
        du -sh site | cut -f1 | xargs echo "Total size:"
    
    - name: Add build metadata
      run: |
        cd docs/site
        
        # Create build info file
        cat > build-info.json << EOF
        {
          "build_time": "$(date -Iseconds)",
          "commit_sha": "${{ github.sha }}",
          "commit_ref": "${{ github.ref }}",
          "workflow_run": "${{ github.run_number }}",
          "link_validation": "${{ needs.validate-links.outputs.validation-passed || 'skipped' }}"
        }
        EOF
        
        # Add build timestamp to footer (if using custom theme)
        echo "<!-- Built on $(date -Iseconds) from commit ${{ github.sha }} -->" >> index.html
    
    - name: Setup Pages
      uses: actions/configure-pages@v4
    
    - name: Upload artifact
      uses: actions/upload-pages-artifact@v3
      with:
        path: 'docs/site'
    
    - name: Deploy to GitHub Pages
      id: deployment
      uses: actions/deploy-pages@v4
    
    - name: Verify deployment
      run: |
        echo "üöÄ Documentation deployed successfully!"
        echo "üìç URL: ${{ steps.deployment.outputs.page_url }}"
        echo "üîó Direct links:"
        echo "  - Home: ${{ steps.deployment.outputs.page_url }}"
        echo "  - ADRs: ${{ steps.deployment.outputs.page_url }}adrs/"
        echo "  - Getting Started: ${{ steps.deployment.outputs.page_url }}GETTING_STARTED/"
        
        # Test deployment with curl
        sleep 30  # Wait for deployment to propagate
        if curl -f -s "${{ steps.deployment.outputs.page_url }}" > /dev/null; then
          echo "‚úÖ Deployment verification successful"
        else
          echo "‚ö†Ô∏è Deployment verification failed - site may still be propagating"
        fi

  # Post-deployment validation
  post-deploy-validation:
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Wait for deployment propagation
      run: sleep 60
    
    - name: Install link checking tools
      run: |
        npm install -g markdown-link-check broken-link-checker
        sudo apt-get update && sudo apt-get install -y curl jq
    
    - name: Validate deployed site accessibility
      run: |
        SITE_URL="${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}"
        echo "üîç Validating deployed site: $SITE_URL"
        
        # Test main pages
        pages_to_test=(
          ""
          "GETTING_STARTED/"
          "adrs/"
          "tutorials/"
          "how-to/"
          "reference/"
        )
        
        failed_pages=()
        for page in "${pages_to_test[@]}"; do
          url="${SITE_URL}${page}"
          echo "Testing: $url"
          if curl -f -s "$url" > /dev/null; then
            echo "‚úÖ $url - OK"
          else
            echo "‚ùå $url - FAILED"
            failed_pages+=("$url")
          fi
        done
        
        if [ ${#failed_pages[@]} -eq 0 ]; then
          echo "üéâ All pages accessible successfully!"
        else
          echo "‚ö†Ô∏è Some pages failed accessibility:"
          printf '%s\n' "${failed_pages[@]}"
          echo "This may be due to propagation delays. Check again in a few minutes."
        fi
    
    - name: Run comprehensive link validation on deployed site
      id: live-validation
      run: |
        SITE_URL="${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}"
        echo "üîó Running comprehensive link validation on live site: $SITE_URL"
        
        # Create reports directory
        mkdir -p live-validation-reports
        
        # Use broken-link-checker to scan the entire deployed site
        echo "Starting broken link checker scan..."
        blc "$SITE_URL" \
          --recursive \
          --ordered \
          --exclude-external \
          --filter-level 3 \
          --requests 5 \
          --max-sockets 10 \
          --timeout 10000 \
          --retry-limit 2 \
          --json > live-validation-reports/broken-links.json || true
        
        # Parse results and create summary
        echo "üìä Generating validation summary..."
        
        # Count broken links
        broken_count=$(jq '[.[] | select(.broken == true)] | length' live-validation-reports/broken-links.json 2>/dev/null || echo "0")
        total_count=$(jq 'length' live-validation-reports/broken-links.json 2>/dev/null || echo "0")
        
        echo "validation_summary<<EOF" >> $GITHUB_OUTPUT
        echo "## üîó Live Site Link Validation Results" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo "**Site URL**: $SITE_URL" >> $GITHUB_OUTPUT
        echo "**Total Links Checked**: $total_count" >> $GITHUB_OUTPUT
        echo "**Broken Links Found**: $broken_count" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        
        if [ "$broken_count" -gt 0 ]; then
          echo "### ‚ùå Broken Links Detected" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "The following links are broken on the live site:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          
          # Extract broken links details
          jq -r '.[] | select(.broken == true) | "- **\(.url.original)** (Status: \(.http.statusCode // "N/A")) on page \(.base.original)"' \
            live-validation-reports/broken-links.json 2>/dev/null | head -20 >> $GITHUB_OUTPUT || true
          
          if [ "$broken_count" -gt 20 ]; then
            echo "" >> $GITHUB_OUTPUT
            echo "*... and $(($broken_count - 20)) more broken links. See full report in artifacts.*" >> $GITHUB_OUTPUT
          fi
          
          echo "" >> $GITHUB_OUTPUT
          echo "### üõ†Ô∏è Next Steps" >> $GITHUB_OUTPUT
          echo "1. Download the validation report artifact for detailed analysis" >> $GITHUB_OUTPUT
          echo "2. Fix broken links in the documentation source" >> $GITHUB_OUTPUT
          echo "3. Test fixes locally using \`cd docs && ./run-docs.sh validate\`" >> $GITHUB_OUTPUT
          echo "4. Commit and push fixes to trigger re-deployment" >> $GITHUB_OUTPUT
          
          echo "status=failed" >> $GITHUB_OUTPUT
        else
          echo "### ‚úÖ All Links Working" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "No broken links detected on the live site! üéâ" >> $GITHUB_OUTPUT
          echo "status=passed" >> $GITHUB_OUTPUT
        fi
        echo "EOF" >> $GITHUB_OUTPUT
    
    - name: Upload live validation report
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: live-site-validation-report
        path: live-validation-reports/
        retention-days: 30
    
    - name: Create GitHub issue for broken links
      if: steps.live-validation.outputs.status == 'failed'
      uses: actions/github-script@v7
      with:
        script: |
          const brokenLinksIssueTitle = 'üîó Broken Links Detected on Live Documentation Site';
          
          // Check if issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['documentation', 'broken-links']
          });
          
          const existingIssue = existingIssues.data.find(issue => 
            issue.title.includes('Broken Links Detected')
          );
          
          const issueBody = `
          ## üîó Broken Links Detected on Live Documentation Site
          
          **Deployment**: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})
          **Site URL**: ${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}
          **Validation Date**: ${new Date().toISOString()}
          
          ${{ steps.live-validation.outputs.validation_summary }}
          
          ### üìã Action Items
          - [ ] Review the [validation report artifact](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          - [ ] Fix broken links in documentation source files
          - [ ] Test fixes locally: \`cd docs && ./run-docs.sh validate\`
          - [ ] Verify fixes on deployed site after re-deployment
          
          ### üîÑ Auto-Resolution
          This issue will be automatically closed when the next deployment passes link validation.
          
          ---
          *This issue was automatically created by the [Deploy Documentation workflow](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*
          `;
          
          if (existingIssue) {
            // Update existing issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: existingIssue.number,
              body: `## üîÑ Updated Broken Links Report\n\n${issueBody}`
            });
          } else {
            // Create new issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: brokenLinksIssueTitle,
              body: issueBody,
              labels: ['documentation', 'broken-links', 'bug']
            });
          }
    
    - name: Close resolved broken links issues
      if: steps.live-validation.outputs.status == 'passed'
      uses: actions/github-script@v7
      with:
        script: |
          // Find and close any open broken links issues
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['documentation', 'broken-links']
          });
          
          for (const issue of existingIssues.data) {
            if (issue.title.includes('Broken Links Detected')) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `## ‚úÖ Broken Links Resolved\n\nAll links are now working on the live documentation site!\n\n**Deployment**: [\`${{ github.sha }}\`](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})\n**Validation Date**: ${new Date().toISOString()}\n\nClosing this issue automatically.`
              });
              
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed'
              });
            }
          }
    
    - name: Create deployment summary
      run: |
        cat >> $GITHUB_STEP_SUMMARY << 'EOF'
        ## üìö Documentation Deployment Summary
        
        ### ‚úÖ Deployment Status: SUCCESS
        
        **üîó Site URL**: ${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}
        
        ### üìä Build Information
        - **Commit**: `${{ github.sha }}`
        - **Branch**: `${{ github.ref_name }}`
        - **Build Time**: $(date -Iseconds)
        - **Pre-Deploy Link Validation**: ${{ needs.validate-links.outputs.validation-passed || 'skipped' }}
        - **Post-Deploy Validation**: Running (see post-deploy-validation job)
        
        ### üéØ Key Pages
        - [üè† Home](${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }})
        - [üìã Getting Started](${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}GETTING_STARTED/)
        - [üèóÔ∏è Architecture Decision Records](${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}adrs/)
        - [üìö Tutorials](${{ needs.deploy.outputs.page_url || format('https://{0}.github.io/{1}/', github.repository_owner, github.event.repository.name) }}tutorials/)
        
        ### üîß Documentation Quality
        - ‚úÖ Pre-deployment source validation performed
        - üîÑ Post-deployment live link validation in progress
        - üìä Comprehensive broken link detection on live site
        - ü§ñ Automatic GitHub issue creation for broken links
        - üìã Detailed validation reports saved as artifacts
        - All documentation follows [ADR-016](https://github.com/${{ github.repository }}/blob/main/docs/content/adrs/016-documentation-link-validation-strategy.md) standards
        
        ### üö® Issue Management
        - Broken links automatically create GitHub issues
        - Issues are auto-closed when links are fixed
        - Validation reports available for download
        
        ---
        *Documentation deployed via GitHub Actions with comprehensive link validation*
        EOF
